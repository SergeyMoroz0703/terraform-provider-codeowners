package codeowners

import (
	"context"
	"fmt"
	"net/http"
	"strings"

	"github.com/google/go-github/github"
)

var codeownersPath = ".github/CODEOWNERS"

type File struct {
	RepositoryName  string
	RepositoryOwner string
	Branch          string
	Ruleset         Ruleset
}

type Ruleset []Rule

type Rule struct {
	Pattern   string
	Usernames []string
}

func (ruleset Ruleset) Equal(comparison Ruleset) bool {
	if len(ruleset) != len(comparison) {
		return false
	}
	for _, rule := range ruleset {
		found := false
		for _, comparisonRule := range comparison {
			if comparisonRule.Pattern == rule.Pattern {
				found = sameStringSlice(rule.Usernames, comparisonRule.Usernames)
			}
		}
		if !found {
			return false
		}
	}
	return true
}

func sameStringSlice(x, y []string) bool {
	if len(x) != len(y) {
		return false
	}
	// create a map of string -> int
	diff := make(map[string]int, len(x))
	for _, _x := range x {
		// 0 value for int is 0, so just increment a counter for the string
		diff[_x]++
	}
	for _, _y := range y {
		// If the string _y is not in diff bail out early
		if _, ok := diff[_y]; !ok {
			return false
		}
		diff[_y] -= 1
		if diff[_y] == 0 {
			delete(diff, _y)
		}
	}
	if len(diff) == 0 {
		return true
	}
	return false
}

func (ruleset Ruleset) Compile() []byte {
	if ruleset == nil {
		return []byte{}
	}
	output := "# automatically generated by terraform - please do not edit here\n"
	for _, rule := range ruleset {
		usernames := ""
		for _, username := range rule.Usernames {
			if !strings.Contains(username, "@") {
				usernames = fmt.Sprintf("%s@%s ", usernames, username)
			} else {
				usernames = fmt.Sprintf("%s%s ", usernames, username)
			}
		}
		output = fmt.Sprintf("%s%s %s\n", output, rule.Pattern, usernames)
	}
	return []byte(output)
}

func updateRulesetForRepo(client *github.Client, branch string, repoOwner string, repoName string, ruleset Ruleset, commitMessage string) error {
	ctx := context.Background()

	getOptions := &github.RepositoryContentGetOptions{}
	if branch != "" {
		getOptions.Ref = branch
	}

	codeOwnerContent, _, rr, err := client.Repositories.GetContents(ctx, repoOwner, repoName, codeownersPath, getOptions)
	if err != nil || rr.StatusCode >= 400 {
		return fmt.Errorf("failed to retrieve file %s: %v", codeownersPath, err)
	}

	options := &github.RepositoryContentFileOptions{
		Content: ruleset.Compile(),
		Message: &commitMessage,
		SHA:     codeOwnerContent.SHA,
	}
	if branch != "" {
		options.Branch = &branch
	}

	_, _, err = client.Repositories.UpdateFile(ctx, repoOwner, repoName, codeownersPath, options)

	return err
}

func createRulesetForRepo(client *github.Client, branch string, repoOwner string, repoName string, ruleset Ruleset, commitMessage string) error {
	ctx := context.Background()

	options := &github.RepositoryContentFileOptions{
		Content: ruleset.Compile(),
		Message: &commitMessage,
	}
	if branch != "" {
		options.Branch = &branch
	}

	_, _, err := client.Repositories.CreateFile(ctx, repoOwner, repoName, codeownersPath, options)

	return err
}

func deleteRulesetForRepo(client *github.Client, branch string, repoOwner string, repoName string, commitMessage string) error {
	ctx := context.Background()

	codeOwnerContent, _, rr, err := client.Repositories.GetContents(ctx, repoOwner, repoName, codeownersPath, &github.RepositoryContentGetOptions{})
	if err != nil {
		return fmt.Errorf("failed to retrieve file %s: %v", codeownersPath, err)
	}

	if rr.StatusCode == http.StatusNotFound { // resource already removed
		return nil
	}

	options := &github.RepositoryContentFileOptions{
		Message: &commitMessage,
		SHA:     codeOwnerContent.SHA,
	}
	if branch != "" {
		options.Branch = &branch
	}

	_, _, err = client.Repositories.DeleteFile(ctx, repoOwner, repoName, codeownersPath, options)

	return err
}

func readRulesetForRepo(client *github.Client, branch string, repoOwner string, repoName string) (Ruleset, error) {

	ctx := context.Background()

	getOptions := &github.RepositoryContentGetOptions{}
	if branch != "" {
		getOptions.Ref = branch
	}

	codeOwnerContent, _, rr, err := client.Repositories.GetContents(ctx, repoOwner, repoName, codeownersPath, getOptions)
	if err != nil || rr.StatusCode >= 500 {
		return nil, fmt.Errorf("failed to retrieve file %s: %v", codeownersPath, err)
	}

	if rr.StatusCode == http.StatusNotFound {
		return nil, fmt.Errorf("file %s does not exist", codeownersPath)
	}

	raw, err := codeOwnerContent.GetContent()
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve content for %s: %s", codeownersPath, err)
	}

	return parseRulesFile(raw), nil

}

func parseRulesFile(data string) Ruleset {

	rules := []Rule{}
	lines := strings.Split(data, "\n")
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if len(trimmed) == 0 {
			continue
		}
		if trimmed[0] == '#' { // ignore comments
			continue
		}
		words := strings.Split(trimmed, " ")
		if len(words) < 2 {
			continue
		}
		rule := Rule{
			Pattern: words[0],
		}
		for _, username := range words[1:] {
			if len(username) == 0 { // may be split by multiple spaces
				continue
			}
			if username[0] == '@' {
				username = username[1:]
			}
			rule.Usernames = append(rule.Usernames, username)
		}
		rules = append(rules, rule)
	}

	return rules

}
